# 垃圾回收简介

介绍 JVM 垃圾回收的基础知识。这里只关注 OpenJDK 的垃圾回收器。

## 5.1 垃圾回收概览

Java 垃圾回收是自动回收的。垃圾回收本质是将不再使用的对象清理掉。现在一般的做法是通过 GC 根（GC root）对象开始搜索。GC 根是可以被堆外访问的对象。
主要包括线程栈和系统类。这些对象总是可达的，它的做法是从一个根对象开始扫描所有可达对象，这些就是活跃对象，不可达的是无效对象。

所有线程都停止工作被称为 **STW 停顿**（stop-the-world）。这些停顿对程序性能影响很大，减少停顿是优化 GC 的重中之重。

### 5.1.1 分代垃圾回收器

大多数垃圾回收器会将堆分为两部分：**老年代**和**新生代**。新生代进一步被分为 **Eden 空间**和 **Survivor 空间**。分代原因是很多对象使用时间
很短，大量对象会被快速创建、快速销毁。对象会先在新生代中分配，新生代满了之后，垃圾回收器会停止所有线程，并清空新生代。

这种设计的优势：新生代只是一小部分，处理速度快，停顿时间少；新生代对象的分配方式是，对象分配到 Eden，清理时，对象移动到 Survivor 空间，相当于
做了一次压缩。

接着，对象被移动到老年代，老年代被填满，JVM 需要清理老年代对象，这个过程叫 Full GC，它会造成应用线程较长时间的停顿。

### 5.1.2 GC 算法

#### 1. Serial 垃圾回收器

单线程处理堆，使用 `-XX:UserSerialGC`指定

#### 2. Throughput 垃圾回收器

并行回收器，它会使用多个线程

#### 3. G1 GC
**G1 GC**（垃圾优先垃圾回收器 garbage first）使用兵法回收策略来以**最小的停顿**回收堆。它是 **JDK11** 后2个以上 CPU 64位机器上的**默认**垃圾回收器。
G1 GC 将堆分为多个 Region（区域或分区），不过它仍然认为堆有两代，一些 Region 是老年代，一些是新生代。回收新生代时，还是需要暂停所有应用线程。老年代回收是
后台线程处理的，大多数工作不需要停止应用程序线程。G1 GC 可以将一个 Region 的老年代复制到另外一个 Region，这意味着它进行了压缩，避免产生过多的
碎片。

使用 `-XX:+UserG1GC` 标志开启。

#### 4. CMS 垃圾回收器
**CMS 垃圾回收器**是第一个并发垃圾回收器。它使用多个线程回收，会在 Minor GC 中 STW。JDK11 后 CMS 被废弃。它的问题是不能在后台处理过程中压缩
堆，这样会产生很多碎片。

使用 `-XX:UseConcMarkSweepGC`开启

#### 5. 实验性垃圾回收器

新实现的垃圾回收器，逐步迭代中

### 5.1.3
暂不深入看

## 5.2 GC 优化基础
### 5.2.1 调整堆大小
堆太大太小都不好，首先太小，应用程序会频繁 GC。太大也不好，因为 GC 停顿时间取决于堆的大小，堆变大，停顿时间也会变大。

堆太大还有个风险，操作系统使用虚拟内存管理机器物理内存，比如一台机器有 8GB 的物理内存，但是操作系统可以让它看起来有 16GB 内存。操作系统可以通过
一个叫作**交换**（或**分页**）的过程来实现这个操作。当需要这些数据时，操作系统将它们再复制到 RAM 中。而且在 Full GC 期间，JVM 必须访问整个
堆，交换肯定会发生。因此，堆大小要小于机器的物理内存。堆大小主要通过两个参数，初始值 -XmsN 和最大值 -XmxN。

### 5.2.2 调整分代大小
-XX:NewRatio=N<br/>
    设置新生代与老年代的比例

-XX:NewSize=N<br/>
    设置新生代的初始值

-XX:MaxNewSize=N<br/>
    设置新生代的最大值

-XmnN<br/>
    将 NewSize 和 MaxNewSize 设置为同一个值的简单写法

#### 自适应大小

### 5.2.3 调整元空间大小
JVM 加载类时，它必须记录这些类的某些元数据。这些数据占据了一个单独的堆空间，叫作**元空间**（metaspace）。老版本中叫作**永久代**（permgen）。
64 位 JVM 的元空间默认初始值是 20.75MB。

### 5.2.4 控制并行
除了 Serial 垃圾回收器，所有的 GC 算法都使用了多线程。这些线程的数量由 -XX:ParallelGCThreads=N 标志控制。

## 5.3 GC 工具
打印 GC 日志

### 5.3.1 在 JDK 8 中开启 GC 日志
设置 -verbose:gc 和 -XX:+PrintGC 其中一个就可以创建 GC 日志。

### 5.3.2 在 JDK 11 中开启 GC 日志
JDK 11 后使用 -Xlog 标志开启

```shell
-Xlog:gc*:file=gc.log:time:filecount=7,filesize=8M
```

可视化场景：jvisualvm 或 jconsole 实时监控堆。
脚本方式（控制台打印）使用 jstat，它有9个选项，jstat -options 可以查看，其中一个是 -gcutil，它可以显示 gc 的时间。
```shell
--                  毫秒
jstat -gcutil <pid> 1000
```

