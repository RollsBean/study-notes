# 使用即时编译器
## 4.1 即时编译器：概览
CPU 只能执行机器码指令。所有语言执行时都需要翻译成这些指令才行。
**编译型语言**：C++ 和 Fortran 是编译型语言，代码完成后，先由静态编译器编译成二进制文件。
**解释性语言**：代码编写完成后，由机器上的解释器翻译并运行

#### 热点编译
JVM 执行代码时，先解释执行，解释执行更快，而且很多代码只执行一次，编译一次白费力气。如果代码频繁调用或迭代多次执行后，再进行编译。这就叫热点编译，
Oracle HostSpot JVM 的名字也是由此得来的。

## 4.2 分层编译
很早之前 JVM 有两种编译器，分别是 client 编译器（C1）和 server 编译器（C2），现在新的 JVM 都可以同时使用 C
和 C2，而不是二选一，这样 JVM 先使用 C1 编译器，随着代码运行，热点代码再使用 C2 编译器。

## 4.2 常用的编译器标志
### 4.3.1 优化代码缓存
当 JVM 编译代码时，它会在代码缓存中保存一系列汇编语言指令。可以通过参数 -XX:ReservedCodeCacheSize=_N_ 标志设置，默认初始大小时 2496KB，
默认最大 240MB。
### 4.3.2 检查编译过程
-XX:+PrintCompilation 标志（默认为 false）可以让我们看到编译器的工作情况。
### 4.4 高级编译标志
### 4.4.1 编译阈值
代码执行到一定的次数就会进行编译，阈值默认是 10000，
### 4.4.3 内联
举例：getter setter 方法编译器会改写成对值的直接修改，而不是调用 getter 和 setter。
```java
Point p = getPoint ( ) ;
p.setX(p.getX() * 2);
```
而编译后的代
码本质上执行的是：
```java
Point p = getPoi.n t();
p.x = p.x * 2;
```
## 4.7 预编译
### 4.7.1 提前编译
提前编译（ahead-of-time，简称 AOT）最初在 Linux JDK9 可用，JDK11 中所有平台都可用了。