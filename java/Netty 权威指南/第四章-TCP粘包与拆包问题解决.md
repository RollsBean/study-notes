# 第四章 - TCP 粘包/拆包问题的解决之道

## 4.1 TCP 粘包/拆包

TCP 是个"流"协议，流没有界限，所以一个完整的包可能会被TCP拆分成多个包发送，也可能多个小的包在一起发送。

### 4.1.2 TCP 粘包/拆包问题说明

![TCP pack&unpack](../../image/java/Netty权威指南/TCP%20pack&unpack.png)

假设客户端发送D1、D2两个数据包给服务端，由于服务端一次读取的数据不确定，可能会存在以下四种情况。

1. **正常**情况：服务端分两次正好读到两个独立的数据包D1和D2，不需要拆包粘包；
2. **粘包**：服务端一次接受到两个数据包，D1和D2，两个包粘合在一起，称为粘包，需要拆包；
3. **拆包**：服务端分两次读到两个数据包，第一次读到完整的D1包和D2的部分包，第二次读到D2的剩余部分，这是TCP拆包；
4. **拆包**：服务端分两次读取到两个数据包，第一次读到D1的部分包，第二次读到D1的剩余内容和D2整包。

### 4.1.2 TCP 粘包/拆包发生的原因

问题原因有三个：

1. 应用程序write写入字节大于套接口发送缓冲区大小；
2. 进行 MSS 大小的TCP分段；
3. 以太网帧的payload大于MTU进行IP分片。

如下图所示：
![TCP pack&unpack reason](../../image/java/Netty权威指南/TCP%20pack&unpack%20reason.png)

### 粘包问题的解决策略

底层TCP 无法理解上层业务数据，所以需要通过上层的应用协议栈设计来解决（应用层协议），主流解决方案：

1. 消息定长，例：每个报文200字节，如果不够，空位补空格；
2. 在包尾增加回车换行符进行分割，例如FTP协议；
3. 将消息分为消息头和消息体，消息头包含消息总长度信息，通常设计思路为消息头的的第一个字段使用int32来表示消息的总程度，如HTTP协议；
4. 更复杂的应用层协议。

补充（网络分层架构）：
![Network%20arch](../../image/java/Netty权威指南/Network%20arch.png)

## 4.2 未考虑TCP 粘包导致功能异常案例

