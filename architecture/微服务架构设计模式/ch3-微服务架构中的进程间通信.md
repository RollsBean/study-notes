# 第三章-微服务架构中的进程间通信

## 进程间通信概述

1. 基于同步请求/响应的通信，例如HTTP REST或gRPC
2. 异步的基于消息的通信机制

### 交互方式

1. 一对一： 一个客户端对应一个服务实例
2. 一对多：一个客户端对应多个服务实例

一对多情况下：
发布/订阅方式：客户端发布通知消息，被多个服务订阅
发布/异步响应方式：客户端发布消息，等待感兴趣的服务发回的响应

### 基于同步的远程过程调用RPC通信

原理：客户端业务逻辑调用代理接口，代理接口由RPC适配器类实现，然后向服务器发送请求，请求由服务器的代理类处理，代理类访问服务器业务逻辑再返回给客户端

## 进程间通信问题及其solution

### 断路器模式处理局部故障

*断路器*：连续失败此处超过指定阈值后一段时间内，这个代理会立即拒绝其他调用。

重点就是不让代理服务一直等待，导致线程阻塞，需要解决两个问题：
1. RPC代理需要有正确处理无响应服务的能力
2. 需要决定何时从失败中恢复

可靠的RPC代理，比如**Netflix Hystrix**：
1. 网络超时返回，异常响应
2. 限制客户端请求数量，限流
3. 断路器模式，高可用

### 服务发现

RPC代理需要知道服务地址（IP和端口），如果是基于云的微服务，IP是动态的，比如k8s，而且服务还需要具有自动扩展、故障和升级。

*服务发现*：服务注册表，数据库中包含服务的地址，服务实例启停时，服务发现会更新注册表

*实现方式*：
1. 服务与客户端直接与服务注册表交互，客户端请求注册表查询api然后请求服务
2. 通过第三方服务作为服务发现实例

*服务发现模式*：
1. 自注册
2. 客户端发现，比如Eureka，基于Spring Cloud客户端自动使用Eureka进行服务发现

## 基于异步消息的通信

###消息

消息由消息头部和消息主体组成，标题是名称与值对的集合，元数据，消息投包含*消息ID*和*返回地址*

### 消息通道Channel

*点对点通道*：一对一，命令式消息使用
*发布-订阅*：一对多，一条消息发送给所有的订阅方，事件式消息使用

*基于代理的消息*：`Apache ActiveMQ` `RabbitMQ` `Apache Kafka`

#### 基于消息的好处

1. 松耦合
2. 消息缓存
3. 灵活通信
4. 明确的进程间通信

#### 弊端

1. 潜在的性能瓶颈
2. 潜在的单点故障，消息代理可能发生故障，消息代理需要是高可用的
3. 复杂性: 架构的复杂性，中间件需要额外维护

### 处理并发和消息顺序

多线程和服务实例并发处理消息需要解决消息幂等性和顺序问题。常见的处理时使用分片（分区），使用分片hash进行路由

#### 处理重复消息

1. 幂等消息处理程序，需要业务逻辑支持
2. 跟踪消息并丢弃重复项， 使用message id跟踪处理，向数据库保存唯一的msg id，如果存在则插入失败

### 事务性消息

不同服务间的数据库不同，跨库事务问题解决方案
1. 使用数据库表OUTBOX作为消息队列，在消息发送方添加一张表管理消息，消息发送方更新添加等操作同步更新OUTBOX，保证原子性，同时还需要消息中继去读OUTBOX
并将数据发布到消息代理。

消息从数据库到消息代理的两种方式
1. 轮询数据库，然后将更新的数据发送给消息代理
2. 使用事务日志拖尾模式发布事件，需要事务日志挖掘，消息中继读取事务日志并将其转换成消息发送到消息代理，比如MySQL订阅binlog，用于Oracle的LinkedIn
Databus等

### 消除同步交互，同步转异步

先返回响应再完成处理







